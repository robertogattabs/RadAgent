% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geoLet.wrappingFunctions.R
\name{GLT.getDoseROIVoxels}
\alias{GLT.getDoseROIVoxels}
\title{Returns the dose voxels internal to a specified ROI}
\usage{
GLT.getDoseROIVoxels(obj.geoLet, Structure, ROIName, newPixelSpacing = NA,
  plotIT = FALSE, verbose = FALSE, forceReCalculus = FALSE,
  fastEngine = TRUE, decimation = FALSE, decimation.percentage = 0.8,
  smoothing = FALSE, smoothing.iterations = 10, interpolate.dose = TRUE)
}
\arguments{
\item{obj.geoLet}{the object geoLet to load the DICOM serie in}

\item{ROIName}{the ROIName that 'contains' the interested voxels. In order to know which are the structure available, please refers to the \code{GTL.getROIList()} and \code{GTL.getROIPointList} functions.}

\item{newPixelSpacing}{Optional. By default it uses same pixelValues of the main CT scan: using this parameter you can pass an array (i.e.: \code{c(.9, .9, 1.5 )} ) to interpolate the voxel space by a trilinear interpolation}

\item{plotIT}{Optional. By default it does not plot anything but if you want, during the comuputation, it can plot the CT scan and the related overlapped dose.}

\item{verbose}{Optional. \code{FALSE} by default. Set to \code{TRUE} it allow to see some logs during the computation}

\item{forceReCalculus}{Optional. \code{FALSE} by default. Due to a caching system, implemented to improve performances, If a previous calculus has been interrupted the afterwards computations (on the same ROI)  could have problems. If a computation has been interrupted it is a good practice to set this parameter to \code{TRUE} in the next computation in order to let the algorithm to re-build anything.}

\item{fastEngine}{\code{TRUE} by default. By default it uses the \code{vcgClostKD()} function which should be quicker but probably a bit less accurate (?). If you want to try something different you can set this parameter on \code{FALSE} and it will use the most classical \code{vcgClost}}

\item{decimation}{Optional. \code{FALSE} by default. Set it to \code{TRUE} if you want to enable decimation to the mesh structure}

\item{smoothing}{Optional, \code{FALSE} by default. This parameter, if se to \code{TRUE} allow to smooth the mesh by a numerical factor indicated in the parameter \code{smoothing.iterations}.}

\item{interpolate.dose}{Optional, \code{TRUE} by default. By default (\code{TRUE}) the returned 3D grid of voxel doses is interpolated according to the pixel spacing of the main CT scan. If you want back a 3D grid voxel doses specified with the same pixelValue but whitout interpolation of the dose value, set this parameter to \code{FALSE}. Personally, I cannot see a good reason to set it to \code{FALSE} but perhaps you need to fit your data with some old algorithm of dose computation and set it to \code{FALSE} can help you in getting more similar results.}

\item{decimationpercentage.}{Optional. 0.8 by default. If the parameter \code{decimation} is set to \code{TRUE} this parameter indicates the percentage of triangles that should be sacrified in the first (and biggest) mesh-model. Killing triangles allows to have an easier to handle mesh and less memory-consumer but reduce the quality of the approximation. In most cases the optimal value has to be defined empirically. If \code{decimation} is set to \code{FALSE} dont's waste your time in tuning this parameter: decimation will not be performed!}

\item{smoothing.terations}{Optional, 10by default. Setting this parameter makes sense only if \code{smoothing} was previously set to \code{TRUE}. Increasing the number of iterations we can improve the "smoothing" applied to the original mesh.}
}
\value{
It returns a list of tree main elements:
\itemize{
   \item{ \code{voxelCube.CT} this is a 3D array which contains the voxel cube of the original CT scan }
   \item{ \code{voxelCube.Dose} this is a 3D array which contains the voxel cube of the DOSES. The dimension is the same of the \code{voxelCube} because the dose value in the space has been interpolated (via triliear interpolation) in order to overlap the centroids of the voxels between \code{voxelCube.CT} and \code{voxelCube.Dose}. This should allow to quickly plot the expected dose value on a specific pixel/voxel in the CT scan. }
   \item{ \code{mesh} is the mesh as returned fro the \pkg{mesh} package.  }    
}
}
\description{
Returns the dose voxels internal to a specified ROI. Please consider that this function return the voxel of the main dose serie. It does not work properly if you have more RD associated to the same SeriesInstanceUID. Because of this function uses mesh calculus, a quite high number of parameters can be passed in order to tune the computation. However, in the most case, the simplest form is preferreable.

              N.B: if you are reading this help probably your car is burning
}
\examples{
\dontrun{

obj<-geoLet()
obj$openDICOMFolder(pathToOpen='./DICOMSeries/pat001' );
obj$GLT.getDoseROIVoxels( Structure = "GTV" )

}
}
